import { timeDifference } from "../util/timeDifference.js";
export class TestNode {
    /** The TestNode type. */
    type = 0 /* TestNodeType.Test */;
    /** The name of the TestNode */
    name = "";
    /** The callback pointer. */
    callback = -1;
    /** If the test is expected to fail. */
    negated = false;
    /** The namespace of this TestNode */
    namespace = "";
    /** The callback pointers that need to be called before each test. */
    beforeEach = [];
    /** The callback pointers that need to be called once before traversing through this node's children. */
    beforeAll = [];
    /** The callback pointers that need to be called after each test. */
    afterEach = [];
    /** The callback pointers that need to be called once after traversing through this node's children. */
    afterAll = [];
    /** Parent TestNode */
    parent = null;
    /** Children TestNodes */
    children = [];
    /** An indicator if the test suite passed. */
    pass = false;
    /** A set of warnings. */
    warnings = [];
    /** A set of errors. */
    errors = [];
    /** A set of logged values. */
    logs = [];
    /** A stack trace for the error. */
    stackTrace = null;
    /** The actual reported value. */
    actual = null;
    /** The expected reported value. */
    expected = null;
    /** Message provided by the abort() function. */
    message = null;
    /** A set of todo messages provided by the testnode. */
    todos = [];
    /** Start time. */
    start = 0;
    /** End time. */
    end = 0;
    /** The number of active heap allocations when the node started. */
    rtraceStart = 0;
    /** The number of active heap allocations when the node ended. */
    rtraceEnd = 0;
    /** If the TestNode ran. */
    ran = false;
    /** The node allocations. */
    allocations = 0;
    /** The node deallocations */
    frees = 0;
    /** The node reallocations. */
    moves = 0;
    /** The delta number of heap allocations. */
    get rtraceDelta() {
        return this.allocations - this.frees;
    }
    /** The difference between the start and end TestNode runtime. */
    get deltaT() {
        return timeDifference(this.end, this.start);
    }
    /**
     * Recursively visit this node's children conditionally. Return false to the callback
     * if you don't want to visit that particular node's children.
     */
    visit(callback) {
        const children = this.children;
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (callback(child) !== false)
                child.visit(callback);
        }
    }
    /** Get this group's todos, recursively. */
    get groupTodos() {
        return [].concat.apply(this.todos, this.groupTests.map((e) => e.todos));
    }
    /** Get this group's tests, recursively. */
    get groupTests() {
        const result = [];
        this.visit((node) => {
            if (node.type === 0 /* TestNodeType.Test */) {
                result.push(node);
            }
            else {
                return false;
            }
        });
        return result;
    }
    /** Get all the groups beneath this node. */
    get childGroups() {
        const result = [];
        this.visit((node) => {
            if (node.type === 1 /* TestNodeType.Group */)
                result.push(node);
        });
        return result;
    }
}
//# sourceMappingURL=TestNode.js.map