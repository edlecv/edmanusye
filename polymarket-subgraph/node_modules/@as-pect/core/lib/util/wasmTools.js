/**
 * A Buffer for reading wasm sections.
 */
export class WasmBuffer {
    u8array;
    /** Current offset in the buffer. */
    off = 0;
    constructor(u8array) {
        this.u8array = u8array;
    }
    /** Read 128LEB unsigned integers. */
    readVaruint(off = this.off) {
        var val = 0;
        var shl = 0;
        var byt;
        var pos = off;
        do {
            byt = this.u8array[pos++];
            val |= (byt & 0x7f) << shl;
            if (!(byt & 0x80))
                break;
            shl += 7;
        } while (true);
        this.off = pos;
        return val;
    }
    /**
     * Read a UTF8 string from the buffer either at the current offset or one passed in.
     * Updates the offset of the buffer.
     */
    readString(off = this.off) {
        const name_len = this.readVaruint(off);
        this.off += name_len;
        const codes = this.u8array.slice(this.off - name_len, this.off);
        let result = "";
        for (let i = 0; i < codes.length; i++) {
            result += String.fromCharCode(codes[i]);
        }
        return result;
    }
    /** Read a string at an offset without changing the buffere's offset. */
    peekString(off) {
        const old_off = this.off;
        const str = this.readString(off);
        this.off = old_off;
        return str;
    }
}
/**
 * Utility class for reading the name sections of a wasm binary.
 * See https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section
 */
export class NameSection {
    section;
    /** map of indexs to UTF8 pointers. */
    funcNames = new Map();
    constructor(contents) {
        const mod = new WebAssembly.Module(contents);
        const section = WebAssembly.Module.customSections(mod, "name")[0];
        this.section = new WasmBuffer(new Uint8Array(section));
        this.parseSection();
    }
    fromIndex(i) {
        const ptr = this.funcNames.get(i);
        if (!ptr)
            return "Function " + i;
        return this.section.peekString(ptr);
    }
    /** Parses */
    parseSection() {
        const off = this.off;
        const kind = this.readVaruint();
        if (kind != 1) {
            this.off = off;
            return;
        }
        const end = this.readVaruint() + this.off;
        const count = this.readVaruint();
        let numRead = 0;
        while (numRead < count && this.off < end) {
            const index = this.readVaruint();
            this.funcNames.set(index, this.off);
            const len = this.readVaruint();
            this.off += len;
            numRead++;
        }
    }
    /** Current offset */
    get off() {
        return this.section.off;
    }
    /** Update offset */
    set off(o) {
        this.section.off = o;
    }
    /** Reads a 128LEB  unsigned integer and updates the offset. */
    readVaruint(off = this.off) {
        return this.section.readVaruint(off);
    }
}
//# sourceMappingURL=wasmTools.js.map