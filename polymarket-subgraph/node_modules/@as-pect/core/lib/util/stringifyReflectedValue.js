import chalk from "chalk";
class StringifyContext {
    level = 0;
    impliedTypeInfo = false;
    seen = new WeakSet();
    keywordFormatter = chalk.yellow;
    stringFormatter = chalk.cyan;
    classNameFormatter = chalk.green;
    numberFormatter = chalk.white;
    indent = 0;
    maxPropertyCount = 50;
    maxLineLength = 80;
    maxExpandLevel = 3;
    tab = 4;
}
export function stringifyReflectedValue(reflectedValue, props) {
    const context = new StringifyContext();
    /* istanbul ignore next */
    if (props.keywordFormatter)
        context.keywordFormatter = props.keywordFormatter;
    /* istanbul ignore next */
    if (props.stringFormatter)
        context.stringFormatter = props.stringFormatter;
    /* istanbul ignore next */
    if (props.classNameFormatter)
        context.classNameFormatter = props.classNameFormatter;
    /* istanbul ignore next */
    if (props.numberFormatter)
        context.numberFormatter = props.numberFormatter;
    /* istanbul ignore next */
    if (props.maxExpandLevel)
        context.maxExpandLevel = props.maxExpandLevel;
    /* istanbul ignore next */
    if (typeof props.indent === "number")
        context.indent = props.indent;
    /* istanbul ignore next */
    if (typeof props.tab === "number")
        context.tab = props.tab;
    /* istanbul ignore next */
    if (typeof props.maxPropertyCount === "number")
        context.maxPropertyCount = props.maxPropertyCount;
    /* istanbul ignore next */
    if (typeof props.maxLineLength === "number")
        context.maxLineLength = props.maxLineLength;
    return formatters[formatterIndexFor(reflectedValue.type, 0 /* ReflectedValueFormatType.Expanded */)](reflectedValue, context);
}
const formatters = [];
/* istanbul ignore next */
const emptyFormatter = () => "";
for (let i = 0; i < 14 * 4; i++)
    formatters.push(emptyFormatter);
const formatterIndexFor = (valueType, type) => valueType * 4 + type;
const falsyFormatter = (reflectedValue) => `${reflectedValue.negated ? "Not " : ""}Falsy`;
formatters[formatterIndexFor(14 /* ReflectedValueType.Falsy */, 0 /* ReflectedValueFormatType.Expanded */)] = falsyFormatter;
const truthyFormatter = (reflectedValue) => `${reflectedValue.negated ? "Not " : ""}Truthy`;
formatters[formatterIndexFor(13 /* ReflectedValueType.Truthy */, 0 /* ReflectedValueFormatType.Expanded */)] = truthyFormatter;
const finiteFormatter = (reflectedValue) => `${reflectedValue.negated ? "Not " : ""}Finite`;
formatters[formatterIndexFor(12 /* ReflectedValueType.Finite */, 0 /* ReflectedValueFormatType.Expanded */)] = finiteFormatter;
function displayBooleanNoSpacing(reflectedValue, ctx) {
    return ctx.keywordFormatter(reflectedValue.value === 1 ? "true" : "false");
}
function displayBooleanWithSpacing(reflectedValue, ctx) {
    return (" ".repeat(ctx.indent + ctx.tab * ctx.level) + ctx.keywordFormatter(reflectedValue.value === 1 ? "true" : "false"));
}
// Booleans
formatters[formatterIndexFor(9 /* ReflectedValueType.Boolean */, 0 /* ReflectedValueFormatType.Expanded */)] =
    displayBooleanWithSpacing;
formatters[formatterIndexFor(9 /* ReflectedValueType.Boolean */, 1 /* ReflectedValueFormatType.Inline */)] = displayBooleanNoSpacing;
formatters[formatterIndexFor(9 /* ReflectedValueType.Boolean */, 2 /* ReflectedValueFormatType.Key */)] = displayBooleanWithSpacing;
formatters[formatterIndexFor(9 /* ReflectedValueType.Boolean */, 3 /* ReflectedValueFormatType.Value */)] = displayBooleanNoSpacing;
function displayClassNoSpacing(reflectedValue, ctx) {
    return ctx.classNameFormatter(`[${reflectedValue.typeName}]`);
}
function displayNumberWithSpacing(reflectedValue, ctx) {
    let numericString = reflectedValue.value.toString();
    if (reflectedValue.type === 8 /* ReflectedValueType.Float */ && !/\.[0-9]/.test(numericString)) {
        numericString += ".0";
    }
    if (ctx.impliedTypeInfo || reflectedValue.typeName === "i32" || reflectedValue.typeName === "f64") {
        return " ".repeat(ctx.indent + ctx.level * ctx.tab) + ctx.numberFormatter(numericString);
    }
    return (" ".repeat(ctx.indent + ctx.level * ctx.tab) +
        `${ctx.numberFormatter(numericString)} ${ctx.keywordFormatter("as")} ${ctx.classNameFormatter(reflectedValue.typeName)}`);
}
function displayNumberNoSpacing(reflectedValue, ctx) {
    let numericString = reflectedValue.value.toString();
    if (reflectedValue.type === 8 /* ReflectedValueType.Float */ && !/\.[0-9]/.test(numericString)) {
        numericString += ".0";
    }
    if (ctx.impliedTypeInfo || reflectedValue.typeName === "i32" || reflectedValue.typeName === "f64") {
        return ctx.numberFormatter(numericString);
    }
    return `${ctx.numberFormatter(numericString)} ${ctx.classNameFormatter(`as ${reflectedValue.typeName}`)}`;
}
// Floats
formatters[formatterIndexFor(8 /* ReflectedValueType.Float */, 0 /* ReflectedValueFormatType.Expanded */)] = displayNumberWithSpacing;
formatters[formatterIndexFor(8 /* ReflectedValueType.Float */, 1 /* ReflectedValueFormatType.Inline */)] = displayNumberNoSpacing;
formatters[formatterIndexFor(8 /* ReflectedValueType.Float */, 2 /* ReflectedValueFormatType.Key */)] = displayNumberWithSpacing;
formatters[formatterIndexFor(8 /* ReflectedValueType.Float */, 3 /* ReflectedValueFormatType.Value */)] = displayNumberNoSpacing;
// Integers
formatters[formatterIndexFor(7 /* ReflectedValueType.Integer */, 0 /* ReflectedValueFormatType.Expanded */)] = displayNumberWithSpacing;
formatters[formatterIndexFor(7 /* ReflectedValueType.Integer */, 1 /* ReflectedValueFormatType.Inline */)] = displayNumberNoSpacing;
formatters[formatterIndexFor(7 /* ReflectedValueType.Integer */, 2 /* ReflectedValueFormatType.Key */)] = displayNumberWithSpacing;
formatters[formatterIndexFor(7 /* ReflectedValueType.Integer */, 3 /* ReflectedValueFormatType.Value */)] = displayNumberNoSpacing;
function displayStringNoSpacing(reflectedValue, ctx) {
    return ctx.stringFormatter(`"${reflectedValue.value.toString().replace(/"/g, '\\"')}"`);
}
function displayStringWithSpacing(hostValue, ctx) {
    return (" ".repeat(ctx.indent + ctx.level * ctx.tab) +
        ctx.stringFormatter(`"${hostValue.value.toString().replace(/"/g, '\\"')}"`));
}
function displayNoQuoteStringWithSpacing(hostValue, ctx) {
    return (" ".repeat(ctx.indent + ctx.level * ctx.tab) +
        ctx.stringFormatter(`${hostValue.value.toString().replace(/"/g, '\\"')}`));
}
// Strings
formatters[formatterIndexFor(2 /* ReflectedValueType.String */, 0 /* ReflectedValueFormatType.Expanded */)] = displayStringWithSpacing;
formatters[formatterIndexFor(2 /* ReflectedValueType.String */, 1 /* ReflectedValueFormatType.Inline */)] = displayStringNoSpacing;
formatters[formatterIndexFor(2 /* ReflectedValueType.String */, 2 /* ReflectedValueFormatType.Key */)] =
    displayNoQuoteStringWithSpacing;
formatters[formatterIndexFor(2 /* ReflectedValueType.String */, 3 /* ReflectedValueFormatType.Value */)] = displayStringNoSpacing;
function displayFunctionExpanded(hostValue, ctx) {
    return (" ".repeat(ctx.indent + ctx.level * ctx.tab) +
        ctx.classNameFormatter(`[Function ${hostValue.pointer}: ${hostValue.value.toString()}]`));
}
const displayFuncNoNameNoPointer = (_, ctx) => ctx.classNameFormatter("[Function]");
// Functions
formatters[formatterIndexFor(6 /* ReflectedValueType.Function */, 0 /* ReflectedValueFormatType.Expanded */)] = displayFunctionExpanded;
formatters[formatterIndexFor(6 /* ReflectedValueType.Function */, 1 /* ReflectedValueFormatType.Inline */)] =
    displayFuncNoNameNoPointer;
formatters[formatterIndexFor(6 /* ReflectedValueType.Function */, 2 /* ReflectedValueFormatType.Key */)] = displayFunctionExpanded;
formatters[formatterIndexFor(6 /* ReflectedValueType.Function */, 3 /* ReflectedValueFormatType.Value */)] = displayFunctionExpanded;
function displayClassExpanded(hostValue, ctx) {
    const spacing = " ".repeat(ctx.level * ctx.tab + ctx.indent);
    if (ctx.seen.has(hostValue))
        return spacing + ctx.classNameFormatter("[Circular Reference]");
    const previousImpliedTypeInfo = ctx.impliedTypeInfo;
    ctx.impliedTypeInfo = false;
    if (hostValue.isNull) {
        if (previousImpliedTypeInfo) {
            return `${spacing}null`;
        }
        else {
            return `${spacing}${ctx.classNameFormatter(`<${hostValue.typeName}>`)}null`;
        }
    }
    ctx.seen.add(hostValue);
    let body = "\n";
    ctx.level += 1;
    const length = hostValue.keys.length;
    const displayCount = Math.min(length, ctx.maxPropertyCount);
    for (let i = 0; i < displayCount; i++) {
        const key = hostValue.keys[i];
        const keyString = formatters[formatterIndexFor(key.type, 2 /* ReflectedValueFormatType.Key */)](key, ctx);
        const value = hostValue.values[i];
        const valueString = ctx.level < ctx.maxExpandLevel
            ? // render expanded value, but trim the whitespace on the left side
                formatters[formatterIndexFor(value.type, 0 /* ReflectedValueFormatType.Expanded */)](value, ctx).trimLeft()
            : // render value
                formatters[formatterIndexFor(value.type, 1 /* ReflectedValueFormatType.Inline */)](value, ctx).trimLeft();
        if (i === displayCount - 1) {
            // remove last trailing comma
            body += `${keyString}: ${valueString}\n`;
        }
        else {
            body += `${keyString}: ${valueString},\n`;
        }
    }
    if (length > ctx.maxPropertyCount)
        body += `${spacing}... +${length - ctx.maxPropertyCount} properties`;
    ctx.level -= 1;
    ctx.impliedTypeInfo = previousImpliedTypeInfo;
    ctx.seen.delete(hostValue);
    if (previousImpliedTypeInfo) {
        return `${spacing}{${body}${spacing}}`;
    }
    else {
        return `${spacing}${ctx.classNameFormatter(hostValue.typeName)} {${body}${spacing}}`;
    }
}
function displayClassWithSpacing(hostValue, ctx) {
    return `${" ".repeat(ctx.level * ctx.tab + ctx.indent)}${ctx.classNameFormatter(`[${hostValue.typeName}]`)}`;
}
// Classes
formatters[formatterIndexFor(1 /* ReflectedValueType.Class */, 0 /* ReflectedValueFormatType.Expanded */)] = displayClassExpanded;
formatters[formatterIndexFor(1 /* ReflectedValueType.Class */, 1 /* ReflectedValueFormatType.Inline */)] = displayClassNoSpacing;
formatters[formatterIndexFor(1 /* ReflectedValueType.Class */, 2 /* ReflectedValueFormatType.Key */)] = displayClassWithSpacing;
formatters[formatterIndexFor(1 /* ReflectedValueType.Class */, 3 /* ReflectedValueFormatType.Value */)] = displayClassExpanded;
function displayArrayExpanded(hostValue, ctx) {
    const spacing = " ".repeat(ctx.level * ctx.tab + ctx.indent);
    if (ctx.seen.has(hostValue))
        return spacing + ctx.classNameFormatter("[Circular Reference]");
    ctx.seen.add(hostValue);
    const previousImpliedTypeInfo = ctx.impliedTypeInfo;
    ctx.impliedTypeInfo = true;
    if (ctx.level < ctx.maxExpandLevel && hostValue.type === 10 /* ReflectedValueType.Array */) {
        // expanded only for arrays
        let body = "\n";
        ctx.level += 1;
        const length = Math.min(hostValue.values.length, ctx.maxPropertyCount);
        for (let i = 0; i < length && i < ctx.maxPropertyCount; i++) {
            const value = hostValue.values[i];
            // render expanded value, but trim the whitespace on the left side
            const valueString = formatters[formatterIndexFor(value.type, 0 /* ReflectedValueFormatType.Expanded */)](value, ctx);
            if (i === length - 1) {
                // remove trailing comma
                body += `${valueString}\n`;
            }
            else {
                body += `${valueString},\n`;
            }
        }
        if (length >= ctx.maxPropertyCount)
            body += `${spacing}... +${length - ctx.maxPropertyCount} values`;
        ctx.level -= 1;
        ctx.impliedTypeInfo = previousImpliedTypeInfo;
        ctx.seen.delete(hostValue);
        if (previousImpliedTypeInfo)
            return `${spacing}[${body}${spacing}]`;
        return `${spacing}${ctx.classNameFormatter(`${hostValue.typeName}`)} [${body}${spacing}]`;
    }
    else {
        // inline
        let body = spacing;
        if (!previousImpliedTypeInfo)
            body += ctx.classNameFormatter(hostValue.typeName) + " ";
        body += "[";
        let i = 0;
        let length = hostValue.values.length;
        const count = Math.min(length, ctx.maxPropertyCount);
        for (; i < count; i++) {
            let value = hostValue.values[i];
            const resultStart = i === 0 ? " " : ", ";
            const result = resultStart + formatters[formatterIndexFor(value.type, 1 /* ReflectedValueFormatType.Inline */)](value, ctx).trimLeft();
            if (body.length + result.length > ctx.maxLineLength) {
                break;
            }
            body += result;
        }
        if (length - i > 0)
            body += `... +${length - i} items`;
        body += " ]";
        ctx.impliedTypeInfo = previousImpliedTypeInfo;
        ctx.seen.delete(hostValue);
        // render value
        return body;
    }
}
// Array
formatters[formatterIndexFor(10 /* ReflectedValueType.Array */, 0 /* ReflectedValueFormatType.Expanded */)] = displayArrayExpanded;
formatters[formatterIndexFor(10 /* ReflectedValueType.Array */, 1 /* ReflectedValueFormatType.Inline */)] = displayArrayExpanded;
formatters[formatterIndexFor(10 /* ReflectedValueType.Array */, 2 /* ReflectedValueFormatType.Key */)] = displayClassWithSpacing;
formatters[formatterIndexFor(10 /* ReflectedValueType.Array */, 3 /* ReflectedValueFormatType.Value */)] = displayArrayExpanded;
// ArrayBuffer
formatters[formatterIndexFor(3 /* ReflectedValueType.ArrayBuffer */, 0 /* ReflectedValueFormatType.Expanded */)] = displayArrayExpanded;
formatters[formatterIndexFor(3 /* ReflectedValueType.ArrayBuffer */, 1 /* ReflectedValueFormatType.Inline */)] = displayArrayExpanded;
formatters[formatterIndexFor(3 /* ReflectedValueType.ArrayBuffer */, 2 /* ReflectedValueFormatType.Key */)] = displayClassWithSpacing;
formatters[formatterIndexFor(3 /* ReflectedValueType.ArrayBuffer */, 3 /* ReflectedValueFormatType.Value */)] = displayArrayExpanded;
// TypedArray
formatters[formatterIndexFor(11 /* ReflectedValueType.TypedArray */, 0 /* ReflectedValueFormatType.Expanded */)] = displayArrayExpanded;
formatters[formatterIndexFor(11 /* ReflectedValueType.TypedArray */, 1 /* ReflectedValueFormatType.Inline */)] = displayArrayExpanded;
formatters[formatterIndexFor(11 /* ReflectedValueType.TypedArray */, 2 /* ReflectedValueFormatType.Key */)] = displayClassWithSpacing;
formatters[formatterIndexFor(11 /* ReflectedValueType.TypedArray */, 3 /* ReflectedValueFormatType.Value */)] = displayArrayExpanded;
// Map
formatters[formatterIndexFor(4 /* ReflectedValueType.Map */, 0 /* ReflectedValueFormatType.Expanded */)] = displayClassExpanded;
formatters[formatterIndexFor(4 /* ReflectedValueType.Map */, 1 /* ReflectedValueFormatType.Inline */)] = displayClassNoSpacing;
formatters[formatterIndexFor(4 /* ReflectedValueType.Map */, 2 /* ReflectedValueFormatType.Key */)] = displayClassWithSpacing;
formatters[formatterIndexFor(4 /* ReflectedValueType.Map */, 3 /* ReflectedValueFormatType.Value */)] = displayClassExpanded;
//# sourceMappingURL=stringifyReflectedValue.js.map